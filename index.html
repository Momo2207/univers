<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Optimized N-Body Simulation (Octree)</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; }
    #info {
      position: absolute;
      top: 10px; left: 10px;
      color: #ddd; font-family: sans-serif; z-index: 10;
      background: rgba(0,0,0,0.5); padding: 10px 16px; border-radius: 8px;
    }
    #info b { color: #fff; }
    #info a { color: #8af; }
  </style>
  
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<div id="info">
  <b>Optimized N-Body Simulation (Octree)</b><br>
  Using Barnes-Hut algorithm for O(n log n) performance.<br>
  Rotate: Drag Mouse   |   Zoom: Mousewheel
</div>

<script type="module">

  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // -------------- THE OCTREE CLASS (BARNES-HUT) --------------
  class Octree {
    constructor(boundary) {
      this.boundary = boundary; // A THREE.Box3
      this.bodies = []; // Bodies in this node
      this.children = null; // 8 child octrees
      
      // Properties for Barnes-Hut approximation
      this.mass = 0;
      this.centerOfMass = new THREE.Vector3();
    }

    insert(body) {
      // If body is outside this node's boundary, ignore it
      if (!this.boundary.containsPoint(body.pos)) {
        return false;
      }

      // If there's space in this node, add the body
      if (this.bodies.length < 1 && this.children === null) {
        this.bodies.push(body);
        return true;
      }

      // If this node is a leaf, but now needs to hold more, subdivide it
      if (this.children === null) {
        this.subdivide();
      }

      // If this node had a body, push it down to a child
      if (this.bodies.length > 0) {
        let existingBody = this.bodies.pop();
        this.insertIntoChildren(existingBody);
      }
      
      // Insert the new body into the appropriate child
      this.insertIntoChildren(body);
      
      return true;
    }
    
    insertIntoChildren(body) {
      for (let i = 0; i < 8; i++) {
        if (this.children[i].insert(body)) {
          return;
        }
      }
    }

    subdivide() {
      this.children = [];
      const size = new THREE.Vector3();
      this.boundary.getSize(size);
      const halfSize = size.clone().multiplyScalar(0.5);
      const center = new THREE.Vector3();
      this.boundary.getCenter(center);
      
      const childCenters = [
        new THREE.Vector3(center.x - halfSize.x/2, center.y + halfSize.y/2, center.z - halfSize.z/2), // Top-Left-Front
        new THREE.Vector3(center.x + halfSize.x/2, center.y + halfSize.y/2, center.z - halfSize.z/2), // Top-Right-Front
        new THREE.Vector3(center.x - halfSize.x/2, center.y - halfSize.y/2, center.z - halfSize.z/2), // Bottom-Left-Front
        new THREE.Vector3(center.x + halfSize.x/2, center.y - halfSize.y/2, center.z - halfSize.z/2), // Bottom-Right-Front
        new THREE.Vector3(center.x - halfSize.x/2, center.y + halfSize.y/2, center.z + halfSize.z/2), // Top-Left-Back
        new THREE.Vector3(center.x + halfSize.x/2, center.y + halfSize.y/2, center.z + halfSize.z/2), // Top-Right-Back
        new THREE.Vector3(center.x - halfSize.x/2, center.y - halfSize.y/2, center.z + halfSize.z/2), // Bottom-Left-Back
        new THREE.Vector3(center.x + halfSize.x/2, center.y - halfSize.y/2, center.z + halfSize.z/2)  // Bottom-Right-Back
      ];

      for (let i = 0; i < 8; i++) {
        let min = new THREE.Vector3().subVectors(childCenters[i], halfSize.clone().multiplyScalar(0.5));
        let max = new THREE.Vector3().addVectors(childCenters[i], halfSize.clone().multiplyScalar(0.5));
        this.children.push(new Octree(new THREE.Box3(min, max)));
      }
    }
    
    computeMassDistribution() {
      if (this.children) {
        // This is an internal node
        this.mass = 0;
        this.centerOfMass.set(0, 0, 0);
        for (const child of this.children) {
          child.computeMassDistribution();
          this.mass += child.mass;
          this.centerOfMass.add(child.centerOfMass.clone().multiplyScalar(child.mass));
        }
        if (this.mass > 0) {
          this.centerOfMass.divideScalar(this.mass);
        }
      } else if (this.bodies.length > 0) {
        // This is a leaf node
        const body = this.bodies[0];
        this.mass = body.mass;
        this.centerOfMass.copy(body.pos);
      } else {
        // Empty leaf node
        this.mass = 0;
        this.centerOfMass.set(0,0,0);
      }
    }
    
    calculateForce(body, theta, G, softening) {
      let force = new THREE.Vector3();
      
      if (this.mass === 0 || (this.bodies.length > 0 && this.bodies[0] === body)) {
        return force;
      }
      
      const s = this.boundary.getSize(new THREE.Vector3()).x; // Width of the region
      const d = body.pos.distanceTo(this.centerOfMass); // Distance to center of mass

      if ((s / d) < theta) {
        // Node is far enough away, approximate as a single body
        const delta = new THREE.Vector3().subVectors(this.centerOfMass, body.pos);
        const distSq = d*d + softening;
        const forceMag = (G * body.mass * this.mass) / distSq;
        force.add(delta.normalize().multiplyScalar(forceMag));
      } else {
        // Node is too close, traverse its children
        if (this.children) {
          for (const child of this.children) {
            force.add(child.calculateForce(body, theta, G, softening));
          }
        } else { // It's a leaf node with a different body
          const otherBody = this.bodies[0];
          const delta = new THREE.Vector3().subVectors(otherBody.pos, body.pos);
          const distSq = delta.lengthSq() + softening;
          const forceMag = (G * body.mass * otherBody.mass) / distSq;
          force.add(delta.normalize().multiplyScalar(forceMag));
        }
      }
      return force;
    }
  }


  // -------------- SCENE SETUP --------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
  camera.position.set(0, 500, 1200);
  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  const controls = new OrbitControls(camera, renderer.domElement);
  scene.add(new THREE.AmbientLight(0xffffff, 0.1));

  // -------------- N-BODY SIMULATION DEFINITION --------------
  const NUM_BODIES = 2500;
  const G = 0.8;
  const INITIAL_SPREAD = 800;
  const BODY_MASS_MIN = 0.1;
  const BODY_MASS_MAX = 4.0;
  const SOFTENING_FACTOR = 10.0;
  const THETA = 0.7; // Barnes-Hut approximation parameter. 0 = exact (slow), > 1 = very inaccurate. 0.5-0.8 is a good range.

  let bodies = [];

  for (let i = 0; i < NUM_BODIES; i++) {
    const theta = Math.random() * 2 * Math.PI;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = Math.cbrt(Math.random()) * INITIAL_SPREAD;
    const pos = new THREE.Vector3(
      r * Math.sin(phi) * Math.cos(theta),
      r * Math.sin(phi) * Math.sin(theta),
      r * Math.cos(phi)
    );
    const vel = new THREE.Vector3(-pos.y, pos.x, 0).normalize();
    vel.multiplyScalar(Math.sqrt(G * NUM_BODIES / (r + 1)) * 0.4);
    vel.add(new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5));
    const mass = BODY_MASS_MIN + Math.random() * (BODY_MASS_MAX - BODY_MASS_MIN);
    const radius = Math.cbrt(mass) * 1.2;
    const color = new THREE.Color().setHSL(0.15 - (mass / BODY_MASS_MAX) * 0.15, 1.0, 0.5 + (mass / BODY_MASS_MAX) * 0.4);
    const material = new THREE.MeshBasicMaterial({ color: color });
    const geometry = new THREE.SphereGeometry(radius, 8, 8); // Reduced sphere detail for performance
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(pos);
    scene.add(mesh);
    bodies.push({ pos, vel, mass, mesh, force: new THREE.Vector3() });
  }

  // -------------- PHYSICS SIMULATION (REWRITTEN) --------------
  function simulate(dt) {
    // 1. Create the root of the Octree, ensuring it's large enough
    const worldBoundary = new THREE.Box3(
        new THREE.Vector3(-INITIAL_SPREAD*2, -INITIAL_SPREAD*2, -INITIAL_SPREAD*2),
        new THREE.Vector3(INITIAL_SPREAD*2, INITIAL_SPREAD*2, INITIAL_SPREAD*2)
    );
    let root = new Octree(worldBoundary);

    // 2. Insert all bodies into the Octree
    for (const body of bodies) {
      root.insert(body);
    }

    // 3. Compute the mass distribution for the entire tree
    root.computeMassDistribution();

    // 4. Calculate forces using the Octree
    for (const body of bodies) {
      body.force.set(0, 0, 0); // Reset force from previous frame
      body.force.add(root.calculateForce(body, THETA, G, SOFTENING_FACTOR));
    }
    
    // 5. Integration (update velocity and position)
    for (const body of bodies) {
      const acceleration = body.force.clone().divideScalar(body.mass);
      body.vel.add(acceleration.multiplyScalar(dt));
      body.pos.add(body.vel.clone().multiplyScalar(dt));
    }
  }

  // -------------- RENDER LOOP --------------
  function animate() {
    requestAnimationFrame(animate);
    
    simulate(0.15); // A slightly larger time step can work with the stable algorithm

    for (let i = 0; i < NUM_BODIES; i++) {
      let body = bodies[i];
      body.mesh.position.copy(body.pos);
    }

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // Responsive resize
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>
</body>
</html>
