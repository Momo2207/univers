<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>N-Body Gravitational Simulation</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; }
    #info {
      position: absolute;
      top: 10px; left: 10px;
      color: #ddd; font-family: sans-serif; z-index: 10;
      background: rgba(0,0,0,0.5); padding: 10px 16px; border-radius: 8px;
    }
    #info b { color: #fff; }
    #info a { color: #8af; }
  </style>
  
  <!-- 
    The importmap tells the browser where to find the Three.js library and its addons
    when we use 'import'. This is the modern, recommended way.
  -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
    }
  }
  </script>
</head>
<body>
<div id="info">
  <b>N-Body Gravitational Simulation</b><br>
  Every body attracts every other body.<br>
  Larger size & whiter color = more massive.<br>
  Rotate: Drag Mouse   |   Zoom: Mousewheel
</div>

<!-- This script is a "module" to allow the use of 'import' statements. -->
<script type="module">

  // Import the main Three.js library and the OrbitControls addon.
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  // -------------- SCENE SETUP --------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
  camera.position.set(0, 150, 400);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  
  // OrbitControls is now imported directly, not as a property of THREE.
  const controls = new OrbitControls(camera, renderer.domElement);
  
  // Add a faint ambient light to give spheres some dimension
  scene.add(new THREE.AmbientLight(0xffffff, 0.1));

  // -------------- N-BODY SIMULATION DEFINITION --------------
  const NUM_BODIES = 500;
  const G = 0.5; // Gravitational constant - tune for best results
  const INITIAL_SPREAD = 200; // How large is the initial cluster
  const BODY_MASS_MIN = 0.1;
  const BODY_MASS_MAX = 3.5;
  
  // A critical factor to prevent extreme forces when particles get too close.
  // It avoids the 1/r^2 singularity, making the simulation stable.
  const SOFTENING_FACTOR = 5.0; 

  let bodies = [];

  for (let i = 0; i < NUM_BODIES; i++) {
    // --- Position: Create a spherical distribution ---
    const theta = Math.random() * 2 * Math.PI;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = Math.cbrt(Math.random()) * INITIAL_SPREAD; // Cube root for uniform volume
    
    const pos = new THREE.Vector3(
      r * Math.sin(phi) * Math.cos(theta),
      r * Math.sin(phi) * Math.sin(theta),
      r * Math.cos(phi)
    );

    // --- Velocity: Give initial tangential velocity for a "galaxy disk" effect ---
    const vel = new THREE.Vector3(-pos.y, pos.x, 0).normalize();
    vel.multiplyScalar(Math.sqrt(G * NUM_BODIES / (r + 1)) * 0.3); // Scale velocity
    vel.add(new THREE.Vector3(
      (Math.random()-0.5)*0.2, 
      (Math.random()-0.5)*0.2, 
      (Math.random()-0.5)*0.2
    ));

    // --- Mass & Appearance ---
    const mass = BODY_MASS_MIN + Math.random() * (BODY_MASS_MAX - BODY_MASS_MIN);
    const radius = Math.cbrt(mass) * 0.8; // Radius proportional to cube root of mass
    
    const color = new THREE.Color();
    // Color map: low mass is red/orange, high mass is yellow/white
    color.setHSL(0.15 - (mass / BODY_MASS_MAX) * 0.15, 1.0, 0.5 + (mass / BODY_MASS_MAX) * 0.4);
    
    const material = new THREE.MeshBasicMaterial({ color: color });
    const geometry = new THREE.SphereGeometry(radius, 12, 12);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(pos);
    
    scene.add(mesh);

    // Store everything in a single object for easy access
    bodies.push({ pos, vel, mass, mesh });
  }

  // -------------- PHYSICS SIMULATION --------------
  const force = new THREE.Vector3();
  const delta = new THREE.Vector3();

  function simulate(dt) {
    // This is an O(n^2) calculation: every body interacts with every other body.
    for (let i = 0; i < NUM_BODIES; i++) {
      let bodyA = bodies[i];
      // Reset force for this frame
      force.set(0, 0, 0);

      for (let j = 0; j < NUM_BODIES; j++) {
        if (i === j) continue;
        let bodyB = bodies[j];

        delta.subVectors(bodyB.pos, bodyA.pos);
        
        // Use squared length for performance, and add softening factor
        let distSq = delta.lengthSq() + SOFTENING_FACTOR;
        
        // Newton's Law of Gravitation: F = G * (m1 * m2) / r^2
        let forceMag = (G * bodyA.mass * bodyB.mass) / distSq;
        
        // Add this force to the total force on bodyA
        force.add(delta.normalize().multiplyScalar(forceMag));
      }

      // Update velocity using acceleration (a = F/m)
      // v_new = v_old + a * dt  =>  v_new = v_old + (F/m) * dt
      bodyA.vel.add(force.multiplyScalar(dt / bodyA.mass));
    }
    
    // --- Integration ---
    // Once all forces are calculated, update all positions.
    for (let i = 0; i < NUM_BODIES; i++) {
      let body = bodies[i];
      body.pos.add(body.vel.clone().multiplyScalar(dt));
    }
  }

  // -------------- RENDER LOOP --------------
  function animate() {
    requestAnimationFrame(animate);
    
    // Use a small, stable time step for the simulation
    simulate(0.1); 

    // Update the visual representation of each body
    for (let i = 0; i < NUM_BODIES; i++) {
      let body = bodies[i];
      body.mesh.position.copy(body.pos);
    }

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // Responsive resize
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
