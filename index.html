<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D String Universe Simulation</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #111; }
    #info {
      position: absolute;
      top: 10px; left: 10px;
      color: #fff; font-family: sans-serif; z-index: 10;
      background: rgba(0,0,0,0.5); padding: 10px 16px; border-radius: 8px;
    }
  </style>
  
  <!--
    THE FIX: Load Three.js and OrbitControls via standard <script> tags.
    This method is more robust and avoids the module import/export errors.
    The main three.js library must be loaded *before* OrbitControls.
  -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

</head>
<body>
<div id="info">
  <b>3D String Universe Simulation</b><br>
  Rotate: Drag Mouse   |   Zoom: Mousewheel
</div>

<!-- Change script type from "module" back to a regular script. -->
<script>
  // The 'import' statements are removed because the scripts above create a global 'THREE' object.
  
  // -------------- SCENE SETUP --------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 70);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // THE FIX: OrbitControls is now part of the global THREE object.
  const controls = new THREE.OrbitControls(camera, renderer.domElement);

  // Add cube frame for reference
  const cubeSize = 40;
  const frame = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
  const frameWire = new THREE.WireframeGeometry(frame);
  const line = new THREE.LineSegments(frameWire, new THREE.LineBasicMaterial({color: 0x444488}));
  scene.add(line);

  // -------------- STRING DEFINITION --------------
  const NUM_STRINGS = 18;
  const NODES_PER_STRING = 14;
  const NODE_MASS = 0.1;
  const SPRING_K = 1.4;
  const SPRING_DAMPING = 0.045;
  const NODE_RADIUS = 0.18;

  function randomUnitVec3() {
    let x = Math.random()-0.5, y = Math.random()-0.5, z = Math.random()-0.5;
    let len = Math.sqrt(x*x + y*y + z*z);
    return new THREE.Vector3(x/len, y/len, z/len);
  }

  // Create multiple random strings in cube
  let strings = [];
  let stringMeshes = [];

  for (let s = 0; s < NUM_STRINGS; s++) {
    const p0 = new THREE.Vector3(
      (Math.random()-0.5) * (cubeSize-6),
      (Math.random()-0.5) * (cubeSize-6),
      (Math.random()-0.5) * (cubeSize-6)
    );
    const p1 = new THREE.Vector3(
      (Math.random()-0.5) * (cubeSize-6),
      (Math.random()-0.5) * (cubeSize-6),
      (Math.random()-0.5) * (cubeSize-6)
    );
    let nodes = [];
    for (let i = 0; i < NODES_PER_STRING; i++) {
      const t = i / (NODES_PER_STRING-1);
      let pos = new THREE.Vector3().lerpVectors(p0, p1, t);
      nodes.push({
        pos,
        vel: randomUnitVec3().multiplyScalar(Math.random() * 0.4),
        mass: NODE_MASS
      });
    }
    strings.push(nodes);

    let geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
    let color = new THREE.Color().setHSL(s / NUM_STRINGS, 1.0, 0.45);
    // THE FIX: The 'linewidth' property was removed from LineBasicMaterial in newer Three.js versions.
    // This won't cause a crash, but it won't work. The line below is compatible.
    let mat = new THREE.LineBasicMaterial({color: color}); 
    let mesh = new THREE.Line(geometry, mat);
    scene.add(mesh);
    stringMeshes.push(mesh);
  }

  // Spheres for string nodes (for aesthetics)
  let nodeMeshes = [];
  for (let s = 0; s < NUM_STRINGS; s++) {
    let spheres = [];
    let c = new THREE.Color().setHSL(s / NUM_STRINGS, 0.6, 0.56);
    let nodeMat = new THREE.MeshBasicMaterial({color: c});
    for (let n = 0; n < NODES_PER_STRING; n++) {
      let mesh = new THREE.Mesh(
        new THREE.SphereGeometry(NODE_RADIUS, 8, 8), nodeMat);
      scene.add(mesh);
      spheres.push(mesh);
    }
    nodeMeshes.push(spheres);
  }

  // -------------- PHYSICS SIMULATION --------------
  function simulate(dt) {
    for (let s = 0; s < NUM_STRINGS; s++) {
      let nodes = strings[s];
      for (let i = 0; i < nodes.length-1; i++) {
        let a = nodes[i], b = nodes[i+1];
        let restLen = a.pos.distanceTo(b.pos);
        if (!a.restLen) a.restLen = restLen * (0.97 + 0.06*Math.random());
        if (!b.restLen) b.restLen = restLen * (0.97 + 0.06*Math.random());

        let delta = new THREE.Vector3().subVectors(b.pos, a.pos);
        let dist = delta.length();
        if (dist === 0) continue; // Avoid division by zero
        let dir = delta.normalize();
        let stretch = dist - a.restLen;
        let force = dir.multiplyScalar(SPRING_K * stretch);
        if (i > 0)
          a.vel.add(force.clone().multiplyScalar(dt/a.mass));
        if (i < nodes.length-2)
          b.vel.add(force.clone().multiplyScalar(-dt/b.mass));
      }
      for (let i = 1; i < nodes.length-1; i++) {
        nodes[i].vel.multiplyScalar(1 - SPRING_DAMPING);
        nodes[i].pos.add(nodes[i].vel.clone().multiplyScalar(dt));
        nodes[i].pos.clamp(
          new THREE.Vector3(-cubeSize/2+1, -cubeSize/2+1, -cubeSize/2+1),
          new THREE.Vector3(cubeSize/2-1, cubeSize/2-1, cubeSize/2-1)
        );
      }
    }
  }

  // -------------- RENDER LOOP --------------
  function animate() {
    requestAnimationFrame(animate);
    simulate(0.23);

    for (let s = 0; s < NUM_STRINGS; s++) {
      let nodes = strings[s];
      let positions = [];
      for (let i = 0; i < nodes.length; i++) {
        positions.push(nodes[i].pos.x, nodes[i].pos.y, nodes[i].pos.z);
        nodeMeshes[s][i].position.copy(nodes[i].pos);
      }
      let mesh = stringMeshes[s];
      mesh.geometry.setAttribute('position',
        new THREE.Float32BufferAttribute(positions, 3));
      mesh.geometry.computeBoundingSphere();
    }
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
