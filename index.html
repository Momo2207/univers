<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D String Universe Simulation</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #111; }
    #info {
      position: absolute;
      top: 10px; left: 10px;
      color: #fff; font-family: sans-serif; z-index: 10;
      background: rgba(0,0,0,0.5); padding: 10px 16px; border-radius: 8px;
    }
  </style>
  <!-- Import map: tells browser what "three" means -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.skypack.dev/three@0.152.2"
    }
  }
  </script>
</head>
<body>
<div id="info">
  <b>3D String Universe Simulation</b><br>
  Rotate: Drag Mouse &nbsp;&nbsp;|&nbsp;&nbsp; Zoom: Mousewheel
</div>
<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "https://cdn.skypack.dev/three@0.152.2/examples/jsm/controls/OrbitControls.js";

  // -------------- SCENE SETUP --------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 70);

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Orbit controls for 3D rotation
  const controls = new OrbitControls(camera, renderer.domElement);

  // Add cube frame for reference
  const cubeSize = 40;
  const frame = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
  const frameWire = new THREE.WireframeGeometry(frame);
  const line = new THREE.LineSegments(frameWire, new THREE.LineBasicMaterial({color: 0x444488}));
  scene.add(line);

  // -------------- STRING DEFINITION --------------
  const NUM_STRINGS = 18;
  const NODES_PER_STRING = 14;
  const NODE_MASS = 0.1;
  const SPRING_K = 1.4;
  const SPRING_DAMPING = 0.045;
  const NODE_RADIUS = 0.18;

  function randomUnitVec3() {
    let x = Math.random()-0.5, y = Math.random()-0.5, z = Math.random()-0.5;
    let len = Math.sqrt(x*x + y*y + z*z);
    return new THREE.Vector3(x/len, y/len, z/len);
  }

  // Create multiple random strings in cube
  let strings = [];
  let stringMeshes = [];

  for (let s = 0; s < NUM_STRINGS; s++) {
    // Random endpoints in cube
    const p0 = new THREE.Vector3(
      (Math.random()-0.5) * (cubeSize-6),
      (Math.random()-0.5) * (cubeSize-6),
      (Math.random()-0.5) * (cubeSize-6)
    );
    const p1 = new THREE.Vector3(
      (Math.random()-0.5) * (cubeSize-6),
      (Math.random()-0.5) * (cubeSize-6),
      (Math.random()-0.5) * (cubeSize-6)
    );
    // Interpolate node positions between endpoints
    let nodes = [];
    for (let i = 0; i < NODES_PER_STRING; i++) {
      const t = i / (NODES_PER_STRING-1);
      let pos = new THREE.Vector3().lerpVectors(p0, p1, t);
      // Give small initial velocity to nodes
      nodes.push({
        pos,
        vel: randomUnitVec3().multiplyScalar(Math.random() * 0.4),
        mass: NODE_MASS
      });
    }
    strings.push(nodes);

    // String mesh (as THREE.Line)
    let geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
    let color = new THREE.Color().setHSL(s / NUM_STRINGS, 1.0, 0.45);
    let mat = new THREE.LineBasicMaterial({color: color, linewidth: 2});
    let mesh = new THREE.Line(geometry, mat);
    scene.add(mesh);
    stringMeshes.push(mesh);
  }

  // Spheres for string nodes (for aesthetics)
  let nodeMeshes = [];
  for (let s = 0; s < NUM_STRINGS; s++) {
    let spheres = [];
    let c = new THREE.Color().setHSL(s / NUM_STRINGS, 0.6, 0.56);
    let nodeMat = new THREE.MeshBasicMaterial({color: c});
    for (let n = 0; n < NODES_PER_STRING; n++) {
      let mesh = new THREE.Mesh(
        new THREE.SphereGeometry(NODE_RADIUS, 8, 8), nodeMat);
      scene.add(mesh);
      spheres.push(mesh);
    }
    nodeMeshes.push(spheres);
  }

  // -------------- PHYSICS SIMULATION --------------
  function simulate(dt) {
    // For each string
    for (let s = 0; s < NUM_STRINGS; s++) {
      let nodes = strings[s];
      // Apply spring forces between nodes
      for (let i = 0; i < nodes.length-1; i++) {
        let a = nodes[i], b = nodes[i+1];
        let restLen = a.pos.distanceTo(b.pos);
        // Slightly perturb equilibrium for waves
        if (!a.restLen) a.restLen = restLen * (0.97 + 0.06*Math.random());
        if (!b.restLen) b.restLen = restLen * (0.97 + 0.06*Math.random());

        let delta = new THREE.Vector3().subVectors(b.pos, a.pos);
        let dist = delta.length();
        let dir = delta.normalize();
        let stretch = dist - a.restLen;
        let force = dir.multiplyScalar(SPRING_K * stretch);
        // Apply to both nodes (except ends, which are fixed)
        if (i > 0)
          a.vel.add(force.clone().multiplyScalar(dt/a.mass));
        if (i < nodes.length-2)
          b.vel.add(force.clone().multiplyScalar(-dt/b.mass));
      }
      // Damping & integration
      for (let i = 1; i < nodes.length-1; i++) { // ends fixed
        nodes[i].vel.multiplyScalar(1 - SPRING_DAMPING);
        nodes[i].pos.add(nodes[i].vel.clone().multiplyScalar(dt));
        // Simple cube boundaries
        nodes[i].pos.clamp(
          new THREE.Vector3(-cubeSize/2+1, -cubeSize/2+1, -cubeSize/2+1),
          new THREE.Vector3(cubeSize/2-1, cubeSize/2-1, cubeSize/2-1)
        );
      }
    }
  }

  // -------------- RENDER LOOP --------------
  function animate() {
    requestAnimationFrame(animate);
    simulate(0.23); // Time step

    // Update meshes
    for (let s = 0; s < NUM_STRINGS; s++) {
      let nodes = strings[s];
      // Update string line
      let positions = [];
      for (let i = 0; i < nodes.length; i++) {
        positions.push(nodes[i].pos.x, nodes[i].pos.y, nodes[i].pos.z);
        // Move node spheres
        nodeMeshes[s][i].position.copy(nodes[i].pos);
      }
      let mesh = stringMeshes[s];
      mesh.geometry.setAttribute('position',
        new THREE.Float32BufferAttribute(positions, 3));
      mesh.geometry.computeBoundingSphere();
      mesh.geometry.attributes.position.needsUpdate = true;
    }
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // Responsive resize
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
